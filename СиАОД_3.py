global tree, root                                       #объявление глобальных переменных
tree = {}                                               #дерево
root = ''                                               #корень дерева


#функция ввода дерева
def input_t(value):
    global root                                         #использование глобальных переменных
    if root == '':                                      #если корень пуст
        root = value                                    #корень равен введённому значению
        tree[value] = [1, '', '', '',]                  #информационная ячейка по значению
    else:                                               #иначе
        node = root                                     #узел равен корню
        while True:                                     #пока истина
            if value == node:                           #если значение равно узлу
                tree[node][0] += 1                      #увеличение счётчика на 1
                break                                   #выход из цикла
            elif value < node:                          #иначе если значение меньше узла
                if tree[node][2] == '':                 #если левый подузел пуст
                    tree[node][2] = value               #левый подузел равен значению
                    tree[value] = [1, node, '', '']     #информационная ячейка по значению, родитель узел
                    break                               #выход из цикла
                else:                                   #иначе
                    node = tree[node][2]                #узел равен левому подузлу
            else:                                       #иначе
                if tree[node][3] == '':                 #если правый подузел пуст
                    tree[node][3] = value               #правый подузел равен значению
                    tree[value] = [1, node, '', '']     #информационная ячейка по значению, родитель узел
                    break                               #выход из цикла
                else:                                   #иначе
                    node = tree[node][3]                #узел равен правому подузлу


#функция вывода дерева
def output_t(node, level):
    if node != '':                                      #если узел не пуст
        output_t(tree[node][3], level + 1)              #рекурсия функции по правому подузлу
        print('    ' * level, end = '')                 #вывод отступа
        print(node, tree[node][0], end = '\n')          #вывод узла и счётчика
        output_t(tree[node][2], level + 1)              #рекурсия функции по левому подузлу


#функция вывода количества цифр в дереве
def nums(node, count):
    if node != '':                                      #если узел не пуст
        for i in node:                                  #цикл по символам в узле
            if i.isdigit():                             #если символ цифра
                count += 1                              #увеличение количества на 1
        count = nums(tree[node][3], count)              #количество равно рекурсии функции по правому подузлу
        count = nums(tree[node][2], count)              #количество равно рекурсии функции по левому подузлу
    return count                                        #возврат количества цифр в дереве


#функция поиска узлов на удаление
def find_del_n(node):
    if node != '':                                      #если узел не пуст
        find_del_n(tree[node][3])                       #рекурсия функции по правому подузлу
        find_del_n(tree[node][2])                       #рекурсия функции по левому подузлу
        if not (node.isdigit()):                        #если узел не число
            del_n(node)                                 #запуск функции удаления узла


#функция удаления узла
def del_n(node):
    global root                                         #использование глобальных переменных
    parent = tree[node][1]                              #родитель равен родителю узла
    flag = 1                                            #флаг на наличие родителя
    if parent != '':                                    #если родитель не пуст
        direction = tree[parent].index(node)            #направление узла в родителе
    else:                                               #иначе
        flag = 0                                        #флаг равен 0
    if tree[node][2] == '' and tree[node][3] == '':     #если левый подузел пуст и правый подузел пуст
        if flag:                                        #если есть родитель
            tree[parent][direction] = ''                #подузел в родителе равен пустому значению
        else:                                           #иначе
            root = ''                                   #корень равен пустому значению
    elif tree[node][2] != '' and tree[node][3] == '':   #иначе если левый подузел не пуст и правый подузел пуст
        if flag:                                        #если есть родитель
            tree[parent][direction] = tree[node][2]     #подузел в родителе равен левому подузлу
        else:                                           #иначе
            root = tree[node][2]                        #корень равен левому подузлу
            tree[root][1] = ''                          #родитель корня равен пустому значению
    elif tree[node][2] == '' and tree[node][3] != '':   #иначе если левый подузел пуст и правый подузел не пуст
        if flag:                                        #если есть родитель
            tree[parent][direction] = tree[node][3]     #подузел в родителе равен правому подузлу
        else:                                           #иначе
            root = tree[node][3]                        #корень равен правому подузлу
            tree[root][1] = ''                          #родитель корня равен пустому значению
    else:                                               #иначе
        r = tree[node][2]                               #замещающее значение равно левому подузлу
        while tree[r][3] != '':                         #пока правый подузел замещающего узла не пуст
            r = tree[r][3]                              #замещающее значение равно правому подузлу
        r_parent = tree[r][1]                           #родитель замещающего узла
        if r_parent != node:                            #если родитель замещающего узла не равен узлу
            tree[r_parent][3] = tree[r][2]              #правый подузел родителя замещающего узла равен левому подузлу замещающего узла
            if tree[r][2] != '':                        #если левый подузел замещающего узла не пуст
                tree[tree[r][2]][1] = r_parent          #родитель левого подузла замещающего узла равен родителю замещающего узла
            tree[r][2] = tree[node][2]                  #левый подузел замещающего узла равен левому подузлу узла
            tree[tree[r][2]][1] = r                     #родитель левого подузла замещающего узла равен замещающему узлу
        tree[r][3] = tree[node][3]                      #правый подузел замещающего узла равен правому подузлу узла
        tree[tree[r][3]][1] = r                         #родитель правого подузла замещающего узла равен замещающему узлу
        if flag:                                        #если есть родитель
            tree[r][1] = parent                         #родитель замещающего узла равен родителю
            tree[parent][direction] = r                 #подузел в родителе равен замещающему узлу
        else:                                           #иначе
            tree[r][1] = ''                             #родитель замещающего узла равен пустому значению
            root = r                                    #корень равен замещающему узлу 


#функция вывода значений узлов в порядке убывания
def output_u(node):
    if node != '':                                      #если узел не пуст
        output_u(tree[node][3])                         #рекурсия функции по правому подузлу
        print(node, tree[node][0])                      #вывод узла и счётчика
        output_u(tree[node][2])                         #рекурсия функции по левому подузлу


print('Введите код для тестирования функции')
print('1 - ввод дерева (0 - чтобы остановить ввод)',
      '2 - вывод дерева',
      '3 - количество цифр в дереве',
      '4 - удаление узлов, содержащих не цифры',
      '5 - вывод значений узлов в порядке убывания',
      '0 - завершение работы', sep = '\n')
vvod = int(input())
while vvod:
    if vvod == 1:
        print('Введите значения для записи в дерево')
        a = input()
        while a != '0':
            input_t(a)
            a = input()
    if vvod == 2:
        output_t(root, 0)
    if vvod == 3:
        print('Количество цифр в дереве:', nums(root, 0))
    if vvod == 4:
        find_del_n(root)
        print('Удаление прошло успешно')
    if vvod == 5:
        output_u(root)
    print('Введите код для тестирования функции')
    vvod = int(input())
